#!/usr/bin/python

############
# Reads Elisa's files generated by the cascade code, and generating C++ code for the PrimaryGeneratorAction part of my NC2 code. FW Sep 2018
############

#
# Imports
#

import re
import pprint
from fractions import Fraction

#
# Globals
#

outfile_name = "CascadeZn.cc"

N_LEVELS = 15;

#n_filenames = {	6 : "64Zn_n15_statistical_KWD3_3_N6intensities.txt" ,
#		5 : "64Zn_n15_statistical_KWD3_3_N5intensities.txt" ,
#		4 : "64Zn_n15_statistical_KWD3_3_N4intensities.txt" ,
#		3 : "64Zn_n15_statistical_KWD3_3_N3intensities.txt" ,
#		2 : "64Zn_n15_statistical_KWD3_3_N2intensities.txt" }

n_filenames = {	15 : "64Zn_INTENS_N15.dat" ,
		14 : "64Zn_INTENS_N14.dat" ,
		13 : "64Zn_INTENS_N13.dat" ,
		12 : "64Zn_INTENS_N12.dat" ,
		11 : "64Zn_INTENS_N11.dat" ,
		10 : "64Zn_INTENS_N10.dat" ,
		9 : "64Zn_INTENS_N9.dat" ,
		8 : "64Zn_INTENS_N8.dat" ,
		7 : "64Zn_INTENS_N7.dat" ,
		6 : "64Zn_INTENS_N6.dat" ,
		5 : "64Zn_INTENS_N5.dat" ,
		4 : "64Zn_INTENS_N4.dat" ,
		3 : "64Zn_INTENS_N3.dat" ,
		2 : "64Zn_INTENS_N2.dat" }
		
energy_filename = "EnergyDiffZn64.dat.txt"

l_names = {	0 : "s" ,
		1 : "p" ,
		2 : "d" ,
		3 : "e" ,
		4 : "f" ,
		5 : "g" ,
		6 : "h" ,
		7 : "i" ,
		8 : "j" ,
		9 : "k" ,
		10 : "l" ,
		11 : "m" ,
		12 : "n" ,
		13 : "o" ,
		14 : "p" ,
		15 : "q" }

#
# Methods
#

def make_name(level):
  #print level
  n = level[0]
  l = level[1]
  j = level[2]
  name_l = l_names[l]
  return ( str(n)+name_l+"_"+str(j) , "level"+str(n)+name_l+"_" + str(level[2].numerator) + "_" + str(level[2].denominator) )
  
  
# from line in the file, get the transition
def get_transitions_old(lines):
  transitions = {}
  for line in lines:
    #print line
    n_i = int(re.search("(N1=\s*)(\d+)",line).group(2))
    n_f = int(re.search("(N2=\s*)(\d+)",line).group(2))
    l_i = int(re.search("(L1=\s*)(\d+)",line).group(2))
    l_f = int(re.search("(L2=\s*)(\d+)",line).group(2))
    j_i = Fraction(re.search("(J1=\s*)(\d+/\d+)",line).group(2))
    j_f = Fraction(re.search("(J2=\s*)(\d+/\d+)",line).group(2))
    intensity = float(re.search("(INT=\s*)(\d+\.\d+[eE][+-]\d+)",line).group(2))
    energy = float(re.search("(EN=\s*)(\d+.\d+)",line).group(2))
    level_i = (n_i,l_i,j_i)
    level_f = (n_f,l_f,j_f)
    transition = {}
    transition["daughter"] = level_f
    transition["intensity"] = intensity
    transition["energy"] = energy
    if level_i in transitions:
      transitions[level_i].append(transition)
    else:
      transitions[level_i] = []
      transitions[level_i].append(transition)
  return transitions    

def get_transitions(lines):
  transitions = {}
  for line in lines:
    content = [x for x in line.split(' ') if len(x)>0 ]
    if content[0]=='11':
      print content
    n_i = int(content[0])
    l_i = int(content[1])
    j_i = Fraction( content[2] + "/2" )
    n_f = int(content[3])
    l_f = int(content[4])
    j_f = Fraction( content[5]+"/2" )
    energy = float(content[6])
    intensity = float(content[7])
    level_i = (n_i,l_i,j_i)
    level_f = (n_f,l_f,j_f)
    transition = {}
    transition["daughter"] = level_f
    transition["intensity"] = intensity
    transition["energy"] = energy
    if level_i in transitions:
      transitions[level_i].append(transition)
    else:
      transitions[level_i] = []
      transitions[level_i].append(transition)
  return transitions

# process input transition file
def read_transition_file(n):
  f = open(n_filenames[n],"r")
  content = f.readlines()
  content = [x.strip("\r\n") for x in content if ( len(x.strip("\r\n")) > 1  and "AV.EN" not in x )] #remove lines and return characters I don`t want
  f.close()
  return content


def read_energies_file():
  f = open(energy_filename,"r")
  content = f.readlines()
  content.pop(0)
  content = [x.strip("\r\n").split("\t") for x in content  if float(x.strip("\r\n").split("\t")[-1]) > 0] #remove lines and return characters I don`t want
  return content


# process n level
def process_level(n,transition_energies):
  lines = read_transition_file(n)
  transitions = get_transitions(lines)
  if(n==2):
    pprint.pprint(transitions)


#read transition energies from MUON code output
def process_transition_energies():
  energies = read_energies_file()
  transitions = {}
  for t in energies:
    n_i = int(t[0])
    l_i = int(t[1])
    j_i = Fraction(t[2])
    n_f = int(t[3])
    l_f = int(t[4])
    j_f = Fraction(t[5])
    energy = float(t[6])
    level_i = (n_i,l_i,j_i)
    level_f = (n_f,l_f,j_f)
    transition = {}
    transition["daughter"] = level_f
    transition["energy"] = energy
    if level_i in transitions:
      transitions[level_i].append(transition)
    else:
      transitions[level_i] = []
      transitions[level_i].append(transition)
  return transitions    



# Recursive function
# check if the daughter levels are implemented
# if not, call this function to implement the daughter leven
def write_level(level,daughters,f):
  f.write("\n")
  level_name = make_name(level)[0]
  var_name = make_name(level)[1]
  f.write('  Level ' + var_name + '(' + str(level[0]) + ',' + str(level[1]) + ',' + str(level[2]) + ', "' + level_name + '");\n')
  for daughter in daughters:
    #first reover pointer of level stored in map
    f.write('  daughter = &((*levels)["' + make_name(daughter["daughter"])[0] + '" ]) ;\n')
    #f.write('  '  + var_name + '.SetTransition(&' + make_name(daughter["daughter"])[1] + ',' + str(daughter["intensity"]) + ',' + str(daughter["energy"]) + '*keV);\n' )
    f.write('  '  + var_name + '.SetTransition(daughter,' + str(daughter["intensity"]) + ',' + str(daughter["energy"]) + '*keV);\n' )
  f.write('  (*levels)[' + var_name + '.GetName()] = ' + var_name + ';\n')
  f.write('  count++;\n')
  f.write("\n")


def implement_level(l_i,transitions,levels_done,f):
    #if it is already implementy, no need to continue
    #print "1: " + str(l_i)
    if l_i in levels_done:
      return
    #check implementation of daughter levels
    for transition in transitions[l_i]:
      #print transition
      if (transition["daughter"] not in levels_done) and (transition["daughter"][0] > 1): 
        implement_level(transition["daughter"],transitions,levels_done,f)
    #implement level
    write_level(l_i,transitions[l_i],f)
    levels_done.append(l_i)
    return

# process n level
def process_level(n,transition_energies):
  lines = read_transition_file(n)
  transitions = get_transitions(lines)
  #update the energies with the MUON code results
  for level_i in transitions:
    #print level_i
    if level_i in transition_energies:
      for transition in transitions[level_i]:
        level_f = transition["daughter"]
        #look for level_f in the second transition list
        for transition_MUON in transition_energies[level_i]:
          if transition_MUON["daughter"] == level_f:
            transition["energy"] = transition_MUON["energy"]
            #print "update " + str(level_i) + " -> " + str(level_f)           
    else:
      pass
  if(n==2):
    pprint.pprint(transitions)
  
  #sanity check
  total = 0.
  total2 = 0.
  for level_i in transitions:
    for transition in transitions[level_i]:
     total = total + transition["intensity"]
     if(transition["daughter"][0] != n):
       total2 = total2 + transition["intensity"]
   
  print "Total transition rate from n=" + str(n) + " = " + str(total)
  print "Total transition rate from n=" + str(n) + " = " + str(total2) + " ignoring n->n transitions"
  
  return transitions
    
# 
# Main function
#

def main():

  #prepare c++ file
  fout = open(outfile_name,"w")
  
  fout.write("//\n")
  fout.write("//\n")
  fout.write("// cascade input for the NC2 MC, generated by parsing the MUON and CASCADE code ouput with generate_levels.py\n")
  fout.write("//\n")
  fout.write("//\n")
  fout.write("\n")
  fout.write("\n")
  fout.write('#include "utils.hh"\n')
  fout.write("\n")
  fout.write("\n")
  fout.write("int SetLevelsFromParser(std::map< std::string, Level >* levels)\n")
  fout.write("{\n")
  fout.write("  int count = 0;\n")

  # Process
  
  transition_energies = process_transition_energies() #all transition energies calculated by the MUON code, with the initial level as a key, followed by a list of transitions
  #pprint.pprint(transition_energies)
  
  #
  # This dictionary contains all the transitions
  #
  transitions={}
  #
  #
  #
  
  for n in range(2,N_LEVELS+1,1):
    transitions.update(process_level(n,transition_energies))
  
    
  # at this point we have levels with transition, time to generate some c++ code
  
  #first do 1s manually, as it doesn`t exist in the "transitions" dict
  s1 = (1,0,Fraction(0.5))
  daughters_1s = []
  write_level(s1,daughters_1s,fout)
  
  #
  fout.write("\n")
  fout.write("  Level* daughter;\n")
  fout.write("\n")
  
  #one can only define a level with all it's daughters, if all the daughters are already defined, so a flag for that
  levels_implemented = []
    
  for level_i in transitions:
    implement_level(level_i,transitions,levels_implemented,fout)
    
  #sanity check
  if len(transitions) == len(levels_implemented):
    print "All levels implemented"
  else:
    print str(len(transitions)-len(levels_implemented)) + " levels are not writtn to output file"
  
  
  
  #close output  
  fout.write("  return count;\n")
  fout.write("}\n")
  fout.close()

if __name__ == "__main__":
    main()
